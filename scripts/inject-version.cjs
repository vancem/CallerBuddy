/**
 * Injects package.json version into the app and PWA artifacts.
 * Run before dev/build (prebuild / predev). Reads BASE_PATH from env for deploy base (e.g. /CallerBuddy/).
 */
const fs = require("fs");
const path = require("path");

const root = path.resolve(__dirname, "..");
const pkg = JSON.parse(fs.readFileSync(path.join(root, "package.json"), "utf8"));
const version = pkg.version;

// Base path for deployed app (e.g. '' or '/CallerBuddy'). No trailing slash.
const basePath = (process.env.BASE_PATH || "").replace(/\/?$/, "") || "";

// 1) src/version.ts
fs.writeFileSync(
  path.join(root, "src", "version.ts"),
  `/** Generated by scripts/inject-version.cjs - do not edit by hand */\nexport const APP_VERSION = "${version}";\n`
);

// 2) manifest.json
const manifestPath = path.join(root, "public", "manifest.json");
const manifest = JSON.parse(fs.readFileSync(manifestPath, "utf8"));
manifest.version = version;
fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 2));

// 3) public/sw.js with versioned cache name (dynamic base path for GitHub Pages)
// Include a build timestamp so the browser always detects a change and reinstalls
// the service worker on every deploy, even when the version string hasn't changed.
const cacheName = `callerbuddy-v${version.replace(/[^a-z0-9.-]/gi, "-")}`;
const buildTime = new Date().toISOString();
const swContent = `/* built: ${buildTime} */
const CACHE_NAME = "${cacheName}";

self.addEventListener("install", (event) => {
  const base = new URL("./", self.location).href;
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => cache.addAll([base, base + "index.html"]))
  );
  self.skipWaiting();
});

self.addEventListener("activate", (event) => {
  event.waitUntil(
    caches.keys().then((keys) => {
      return Promise.all(
        keys.filter((key) => key !== CACHE_NAME).map((key) => caches.delete(key))
      );
    })
  );
  self.clients.claim();
});

self.addEventListener("fetch", (event) => {
  if (!event.request.url.startsWith(self.location.origin)) return;

  // Navigation requests (HTML pages): always try network first so the browser
  // never gets stuck on a stale cached index.html referencing old asset hashes.
  if (event.request.mode === "navigate") {
    event.respondWith(
      fetch(event.request)
        .then((response) => {
          const clone = response.clone();
          caches.open(CACHE_NAME).then((cache) => cache.put(event.request, clone));
          return response;
        })
        .catch(() => caches.match(event.request))
    );
    return;
  }

  // Sub-resources (JS, CSS, images): cache-first for speed.
  event.respondWith(
    caches.match(event.request).then((cached) => {
      return cached ?? fetch(event.request);
    })
  );
});
`;
fs.writeFileSync(path.join(root, "public", "sw.js"), swContent);

console.log("Injected version:", version, basePath ? `(base: ${basePath})` : "");
